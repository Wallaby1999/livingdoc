:imagesoutdir: .

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifndef::env-github[]
:icons: font
endif::[]

:toc: 
:toc-placement!:

== Living Documentation Lab

=== Motivation
Documentation is hard. Every programmer knows this. It's also boring and repetitive, and the result often looks ugly
and is hard to read (because not all programmers are poets). The fact that written documentation is usually outdated
before it has been finished doesn't make it any better.

Therefore, writing documentation it is usually something programmers try to avoid.

There is a simple truth you will often hear when talking to programmers about documentation: the most accurate
documentation is the code itself. It's the only thing that won't become outdated, won't lie to you, and will always be
complete.

But code is difficult to understand. If you have ever tried to learn about a code base without written documentation,
you'll know that it is very, very hard to glean the truth from it.

==== Living Diagrams

===== History
The idea to generate UML diagrams from source code is not new. Actually, it has a long history in software development,
a history that is often quite disappointing. Some examples are:

====== UML tool suites
There are tools like Together, Rational Rose, Enterprise Architect etc. These often do a decent job generating UML
diagrams and sometimes even provide full Roundtrip-Engineering capabilities. However, they are usually extremely
expensive, have a high learning curve and force the development team to fully buy into their proprietary way of working.
In addition, the resulting diagrams are difficult to integrate into the actual documentation written outside of the tool
itself, so often users will find themeselves resorting to pasting image files that are - again - difficult to keep
up-to-date.

====== IDEs
// IntelliJ, Netbeans, Eclipse
====== Dedicated generators
// e.g. https://github.com/gboersma/uml-java-doclet

=== The PlantUML Class Diagram Generator
Our generator is different from all theses examples because it follows the ideas of Living Documentation.

==== Design principles
The generator is designed around a limited set of principles derived from the idea of Living Documentation:

Relevance::
The programmer decides what elements from the sources should show up in generated diagrams, so they are always relevant
to the documentation
Proximity::
Diagram controls are an intrinsic part of the source code
Configurability::
Diagram Controls give the developer a lot of control over what is generated
Currentness::
Diagrams are re-generated with every build

==== PlantUML annotation library
At the moment, the annotation library contains only a few annotations that can be used for class diagrams:

link:src/main/java/com/comsysto/livingdoc/annotation/plantuml/PlantUmlClass.java[@PlantUmlClass]::
This is the main annotation to be used for class diagrams. When added to a Java type (interface, class or enum), a
representation of this type is included in one or more diagrams
link:src/main/java/com/comsysto/livingdoc/annotation/plantuml/PlantUmlField.java[@PlantUmlField]::
This annotation may be added to a field within a type already annotated with **@PlantUmlClass**. It will render the
field as part of the class body and/or add an association to the field's type, provided that type is also part of the
diagram
link:src/main/java/com/comsysto/livingdoc/annotation/plantuml/PlantUmlNote.java[@PlantUmlNote]::
This annotation may be used to associate one or more UML notes with a type, providing further textual description

==== PlantUML annotation processor
The annotation processor is a normal Java annotation processor that can be included easily as a Java compiler argument -
either using the programmer's favorite Java IDE's project configuration, or as part of the build process.
The annotation processor produces a model of the elements to be rendered in the resulting diagrams and then outputs the
PlantUML source code.

===== PlantUML diagram model

ifdef::env-github[]
image::annotation-processors/doc/annotation-processor_class.png[Annotation processor classes]
endif::[]
ifndef::env-github[]
plantuml::annotation-processors/doc/annotation-processor_class.puml[imagesoutdir="./annotation-processors/doc"]
endif::[]

NOTE: It may occur to the reader that the diagram above is a handwritten PlantUML class diagram - it hasn't been
auto-generated using the annotation processor. So, why are we not 'eating our own dog food' here?
The reason is simple: while it is possible to use an annotation processor on itself, it's definitely not a good idea
because a functional error in the processor or its templates might stop the code from compiling and create a cyclic
issue that is difficult to debug.

=== Example
As an example, the test sources contain an artificial class hierarchy that models different types of vehicles. The
following diagram is auto-generated using the annotation processor - you can verify this by changing something in the
code and re-run the build:

ifdef::env-github[]
image::annotation-processors/doc/package_class.png[Annotation processor classes]
endif::[]
ifndef::env-github[]
plantuml::annotation-processors/out/package_class.puml[imagesoutdir="./annotation-processors/doc"]
endif::[]

== What's next?
The first version of something is seldom perfect. There is a lot more that could be done:

* Support for additional class diagram elements
* Support for other diagram types
* Refactoring

=== Support for additional class diagram elements

While the feature set supported by the annotation processor is enough
to use it in a productive way, the limits of what may be rendered into the resulting class diagrams are still obvious.
For example, there is no support yet for:

* Methods
* Relation notes
* Special associations like aggregation and composition
* Floating notes
* Generics
* Stereotypes
* ...

=== Support for other diagram types

For us, generating class diagrams is only a first step. Going further, we'd like to investigate rendering other diagram
types. The class diagram was the obvious place to start, since its features closely match the information that can be
gleaned from the information harvested by the annotation processing environment.

=== Refactoring

The current model can be extended to support at least some of those things. We may, however, reach a point in the future
where our first shot at modelling reaches its limits



